diff --git a/yabee_libs/egg_writer.py b/yabee_libs/egg_writer.py
index 8270b60..9414277 100644
--- a/yabee_libs/egg_writer.py
+++ b/yabee_libs/egg_writer.py
@@ -198,10 +198,10 @@ class Group:
         egg_str = []
         if self.object:
             if self.object.__class__ == bpy.types.Bone:
-                egg_str.append( '%s<Joint> %s {\n' % ('  ' * level, eggSafeName(self.object.yabee_name)) )
+                egg_str.append( '%s<Joint> %s {\n' % ('  ' * level, eggSafeName(self.object['yabee_name'])) )
                 #self._yabee_object = EGGJointObjectData(self.object, {}, self.arm_owner)
             else:
-                egg_str.append( '%s<Group> %s {\n' % ('  ' * level, eggSafeName(self.object.yabee_name)) )
+                egg_str.append( '%s<Group> %s {\n' % ('  ' * level, eggSafeName(self.object['yabee_name'])) )
                 egg_str.append( self.get_tags_egg_str(level + 1) )
                 if self.object.type == 'MESH' \
                    and (self.object.data.shape_keys \
@@ -239,12 +239,12 @@ class EGGArmature(Group):
         egg_str = ''
         if self.object:
             #egg_str += '%s<Joint> %s {\n' % ('  ' * level, eggSafeName(self.object.name))
-            egg_str += '%s<Joint> %s {\n' % ('  ' * level, eggSafeName(self.object.yabee_name))
+            egg_str += '%s<Joint> %s {\n' % ('  ' * level, eggSafeName(self.object['yabee_name']))
             # Get vertices reference by Bone name from globlal armature vref
             #if self.object.name in list(vrefs.keys()):
             #    vref = vrefs[self.object.name]
-            if self.object.yabee_name in list(vrefs.keys()):
-                vref = vrefs[self.object.yabee_name]
+            if self.object['yabee_name'] in list(vrefs.keys()):
+                vref = vrefs[self.object['yabee_name']]
             else:
                 vref = {}
             joint = EGGJointObjectData(self.object, vref, arm_owner)
@@ -312,7 +312,7 @@ class EGGNurbsCurveObjectData(EGGBaseObjectData):
         vtx_pool = ''
         vertices = self.collect_vertices()
         if vertices:
-            vtx_pool = '<VertexPool> %s {\n' % eggSafeName(self.obj_ref.yabee_name)
+            vtx_pool = '<VertexPool> %s {\n' % eggSafeName(self.obj_ref['yabee_name'])
             for vtx_str in vertices:
                 for line in vtx_str.splitlines():
                     vtx_pool += '  ' + line + '\n'
@@ -346,7 +346,7 @@ class EGGNurbsCurveObjectData(EGGBaseObjectData):
                 cur_str += '  <Knots> { %s }\n' % ' '.join(map(str2f, knots))
                 cur_str += '  <VertexRef> {\n    %s\n    <Ref> { %s } \n  }\n' % (
                         ' '.join([str(i) for i in range(idx, idx + \
-                        spline.point_count_u)]), eggSafeName(self.obj_ref.yabee_name))
+                        spline.point_count_u)]), eggSafeName(self.obj_ref['yabee_name']))
                 cur_str += '}\n'
                 idx += spline.point_count_u
         return cur_str
@@ -757,7 +757,7 @@ class EGGMeshObjectData(EGGBaseObjectData):
                         if facedata.image:
 
                             # If the polygon is assigned, store a reference to that texture
-                            tex_name = '%s_%s' % (uv_tex.name, facedata.image.yabee_name)
+                            tex_name = '%s_%s' % (uv_tex.name, facedata.image['yabee_name'])
                             if tex_name in USED_TEXTURES and tex_name not in textures:
                                 textures.append(tex_name)
 
@@ -792,7 +792,7 @@ class EGGMeshObjectData(EGGBaseObjectData):
                 else:
 
                     # Look up original texture name before it was copied/renamed
-                    orig_tex_names = material.yabee_texture_slots.split(NAME_SEPARATOR)
+                    orig_tex_names = material['yabee_texture_slots'].split(NAME_SEPARATOR)
 
                     # Just store all texture slots
                     for index, texture in enumerate(material.texture_slots):
@@ -823,7 +823,7 @@ class EGGMeshObjectData(EGGBaseObjectData):
                         params = (params[0], params[0], params[1])
                     if params[2]:
                         attributes.append('<TRef> { %s }' \
-                                    % eggSafeName(self.obj_ref.yabee_name \
+                                    % eggSafeName(self.obj_ref['yabee_name'] \
                                     + '_' + btype))
 
         return attributes
@@ -840,7 +840,7 @@ class EGGMeshObjectData(EGGBaseObjectData):
             mat = self.obj_ref.data.materials[face.material_index]
             if not mat:
                 return attributes
-            attributes.append('<MRef> { %s }' % eggSafeName(mat.yabee_name))
+            attributes.append('<MRef> { %s }' % eggSafeName(mat['yabee_name']))
         return attributes
 
     def collect_poly_normal(self, face, attributes):
@@ -894,7 +894,7 @@ class EGGMeshObjectData(EGGBaseObjectData):
         @return: list of polygon's attributes.
         """
         vr = ' '.join(map(str,self.poly_vtx_ref[face.index]))
-        attributes.append('<VertexRef> { %s <Ref> { %s }}' % (vr, eggSafeName(self.obj_ref.yabee_name)))
+        attributes.append('<VertexRef> { %s <Ref> { %s }}' % (vr, eggSafeName(self.obj_ref['yabee_name'])))
         return attributes
 
     def collect_polygons(self):
@@ -927,7 +927,7 @@ class EGGMeshObjectData(EGGBaseObjectData):
     def get_vtx_pool_str(self):
         """ Return the vertex pool string in the EGG syntax.
         """
-        vtx_pool = '<VertexPool> %s {\n' % eggSafeName(self.obj_ref.yabee_name)
+        vtx_pool = '<VertexPool> %s {\n' % eggSafeName(self.obj_ref['yabee_name'])
         vtxs = ''.join(self.collect_vertices())
         vtxs = vtxs.replace('\n', '\n  ')
         vtx_pool += vtxs
@@ -974,9 +974,9 @@ class EGGActorObjectData(EGGMeshObjectData):
                     if gname not in list(joint_vref.keys()):
                         joint_vref[gname] = {}
                     # Object name = vertices pool name
-                    if self.obj_ref.yabee_name not in list(joint_vref[gname].keys()):
-                        joint_vref[gname][self.obj_ref.yabee_name] = []
-                    joint_vref[gname][self.obj_ref.yabee_name].append((idx, g.weight))
+                    if self.obj_ref['yabee_name'] not in list(joint_vref[gname].keys()):
+                        joint_vref[gname][self.obj_ref['yabee_name']] = []
+                    joint_vref[gname][self.obj_ref['yabee_name']].append((idx, g.weight))
                 idx += 1
         return joint_vref
 
@@ -1034,8 +1034,8 @@ class EGGAnimJoint(Group):
         """
         egg_str = ''
         if self.object:
-            egg_str += '%s<Table> %s {\n' % ('  ' * level, eggSafeName(self.object.yabee_name))
-            bone_data = anim_info['<skeleton>'][self.object.yabee_name]
+            egg_str += '%s<Table> %s {\n' % ('  ' * level, eggSafeName(self.object['yabee_name']))
+            bone_data = anim_info['<skeleton>'][self.object['yabee_name']]
             egg_str += '%s  <Xfm$Anim> xform {\n' % ('  ' * level)
             egg_str += '%s    <Scalar> order { sprht }\n' % ('  ' * level)
             egg_str += '%s    <Scalar> fps { %i }\n' % ('  ' * level, framerate)
@@ -1101,17 +1101,17 @@ class AnimCollector():
                                         self.collect_arm_anims(mod.object)
                     '''
                     if ((obj.data.shape_keys) and (len(obj.data.shape_keys.key_blocks) > 1)):
-                        if obj.yabee_name not in list(self.obj_anim_ref.keys()):
-                            self.obj_anim_ref[obj.yabee_name] = {}
-                        self.obj_anim_ref[obj.yabee_name]['morph'] = self.collect_morph_anims(obj)
+                        if obj['yabee_name'] not in list(self.obj_anim_ref.keys()):
+                            self.obj_anim_ref[obj['yabee_name']] = {}
+                        self.obj_anim_ref[obj['yabee_name']]['morph'] = self.collect_morph_anims(obj)
                 elif obj.type == 'ARMATURE':
                     if action and obj.animation_data:
                         obj.animation_data.action = action
-                    self.bone_groups[obj.yabee_name] = EGGAnimJoint(None)
-                    self.bone_groups[obj.yabee_name].make_hierarchy_from_list(obj.data.bones)
-                    if obj.yabee_name not in list(self.obj_anim_ref.keys()):
-                        self.obj_anim_ref[obj.yabee_name] = {}
-                    self.obj_anim_ref[obj.yabee_name]['<skeleton>'] = \
+                    self.bone_groups[obj['yabee_name']] = EGGAnimJoint(None)
+                    self.bone_groups[obj['yabee_name']].make_hierarchy_from_list(obj.data.bones)
+                    if obj['yabee_name'] not in list(self.obj_anim_ref.keys()):
+                        self.obj_anim_ref[obj['yabee_name']] = {}
+                    self.obj_anim_ref[obj['yabee_name']]['<skeleton>'] = \
                             self.collect_arm_anims(obj)
     def collect_morph_anims(self, obj):
         """ Collect an animation data for the morph target (shapekeys).
@@ -1144,28 +1144,28 @@ class AnimCollector():
             bpy.context.scene.frame_current = f
             bpy.context.scene.frame_set(f)
             for bone in arm.pose.bones:
-                if bone.yabee_name not in list(anim_dict.keys()):
-                    anim_dict[bone.yabee_name] = {}
+                if bone['yabee_name'] not in list(anim_dict.keys()):
+                    anim_dict[bone['yabee_name']] = {}
                 for k in 'ijkabcrphxyz':
-                    if k not in list(anim_dict[bone.yabee_name].keys()):
-                        anim_dict[bone.yabee_name][k] = []
+                    if k not in list(anim_dict[bone['yabee_name']].keys()):
+                        anim_dict[bone['yabee_name']][k] = []
                 if bone.parent:
                     matrix = bone.parent.matrix.inverted() * bone.matrix
                 else:
                     matrix = arm.matrix_world * bone.matrix
 
                 i, j, k = matrix.to_scale()
-                anim_dict[bone.yabee_name]['i'].append(i)
-                anim_dict[bone.yabee_name]['j'].append(j)
-                anim_dict[bone.yabee_name]['k'].append(k)
+                anim_dict[bone['yabee_name']]['i'].append(i)
+                anim_dict[bone['yabee_name']]['j'].append(j)
+                anim_dict[bone['yabee_name']]['k'].append(k)
                 p, r, h = matrix.to_euler()
-                anim_dict[bone.yabee_name]['p'].append(p/pi*180)
-                anim_dict[bone.yabee_name]['r'].append(r/pi*180)
-                anim_dict[bone.yabee_name]['h'].append(h/pi*180)
+                anim_dict[bone['yabee_name']]['p'].append(p/pi*180)
+                anim_dict[bone['yabee_name']]['r'].append(r/pi*180)
+                anim_dict[bone['yabee_name']]['h'].append(h/pi*180)
                 x, y, z = matrix.to_translation()
-                anim_dict[bone.yabee_name]['x'].append(x)
-                anim_dict[bone.yabee_name]['y'].append(y)
-                anim_dict[bone.yabee_name]['z'].append(z)
+                anim_dict[bone['yabee_name']]['x'].append(x)
+                anim_dict[bone['yabee_name']]['y'].append(y)
+                anim_dict[bone['yabee_name']]['z'].append(z)
         bpy.context.scene.frame_current = current_f
         return anim_dict
 
@@ -1210,7 +1210,7 @@ class AnimCollector():
         if self.obj_anim_ref:
             egg_str += '<Table> {\n'
             for obj_name, obj_data in self.obj_anim_ref.items():
-                yabee_obj_name = bpy.data.objects[obj_name].yabee_name
+                yabee_obj_name = bpy.data.objects[obj_name]['yabee_name']
                 if self.name:
                     anim_name = self.name
                 else:
@@ -1240,7 +1240,7 @@ def get_used_materials(objects):
                 if f.material_index < len(obj.data.materials):
                     if not obj.data.materials[f.material_index]:
                         continue
-                    m_list.append(obj.data.materials[f.material_index].yabee_name)
+                    m_list.append(obj.data.materials[f.material_index]['yabee_name'])
     return set(m_list)
 
 
@@ -1254,7 +1254,7 @@ def get_egg_materials_str(object_names=None):
         objects = []
         for name in object_names:
             for obj in bpy.context.scene.objects:
-                if obj.yabee_name == name:
+                if obj['yabee_name'] == name:
                     objects.append(obj)
     if not objects:
         return ''
@@ -1264,7 +1264,7 @@ def get_egg_materials_str(object_names=None):
     containsPBRNodes = False
     for m_idx in used_materials:
         mat = bpy.data.materials[m_idx]
-        mat_str += '<Material> %s {\n' % eggSafeName(mat.yabee_name)
+        mat_str += '<Material> %s {\n' % eggSafeName(mat['yabee_name'])
         #MARK
         
         matIsFancyPBRNode = False
@@ -1538,7 +1538,7 @@ def reparenting_to_armature(obj_list):
         for mod in obj.modifiers:
             if mod and mod.type == 'ARMATURE' and mod.show_viewport:
                 if mod.object and obj.parent != mod.object:
-                    print('WARNING:Reparent %s to %s' % (obj.yabee_name, mod.object.yabee_name))
+                    print('WARNING:Reparent %s to %s' % (obj['yabee_name'], mod.object['yabee_name']))
                     m = Matrix(obj.matrix_world)
                     obj.parent = mod.object
                     obj.matrix_world = m
@@ -1616,28 +1616,28 @@ def write_out(fname, anims, from_actions, uv_img_as_tex, sep_anim, a_only,
     #selected_obj = [obj.name for obj in bpy.context.selected_objects if obj.type != 'ARMATURE']
     selected_obj = objects
     if not selected_obj:
-        selected_obj = [obj.name for obj in bpy.context.selected_objects]
+        selected_obj = [obj.name for obj in bpy.context.selectable_objects]
     for obj in bpy.data.objects:
-        obj.yabee_name = obj.name
+        obj['yabee_name'] = obj.name
     for item in (bpy.data.meshes, bpy.data.textures,
                  bpy.data.curves, bpy.data.shape_keys, bpy.data.images):
         for obj in item:
-            obj.yabee_name = obj.name
+            obj['yabee_name'] = obj.name
     for obj in bpy.data.materials:
-        obj.yabee_name = obj.name
+        obj['yabee_name'] = obj.name
         ts_names = []
         for tex in obj.texture_slots.values():
             ts_names.append(tex and tex.name or "")
         tsmap = NAME_SEPARATOR.join(ts_names)
-        obj.yabee_texture_slots = tsmap
+        obj['yabee_texture_slots'] = tsmap
     for arm in bpy.data.armatures:
-        arm.yabee_name = arm.name
+        arm['yabee_name'] = arm.name
         for bone in arm.bones:
-            bone.yabee_name = bone.name
+            bone['yabee_name'] = bone.name
     for obj in bpy.context.scene.objects:
         if obj.type == 'ARMATURE':
             for bone in obj.pose.bones:
-                bone.yabee_name = bone.name
+                bone['yabee_name'] = bone.name
 
     old_data = {}
     for d in (bpy.data.materials, bpy.data.objects, bpy.data.textures,
@@ -1654,12 +1654,12 @@ def write_out(fname, anims, from_actions, uv_img_as_tex, sep_anim, a_only,
     if USE_LOOP_NORMALS:
         #even obj.data.copy() will not contain loop normals
         precopy_obj_list = [obj for obj in bpy.context.scene.objects
-                    if obj.yabee_name in selected_obj]
+                    if obj['yabee_name'] in selected_obj]
 
     bpy.ops.scene.new(type = 'FULL_COPY')
     try:
         obj_list = [obj for obj in bpy.context.scene.objects
-                    if obj.yabee_name in selected_obj]
+                    if obj['yabee_name'] in selected_obj]
         if USE_LOOP_NORMALS:
             for old, new in zip(precopy_obj_list, obj_list):
                 if old.type != "MESH":
@@ -1684,7 +1684,7 @@ def write_out(fname, anims, from_actions, uv_img_as_tex, sep_anim, a_only,
                 for face in obj.data.polygons:
                     if len(face.vertices) > 4:
                         obj.modifiers.new('triangulate_for_TBS', 'TRIANGULATE')
-                        print('WARNING:TBS: Triangulate %s to avoid non tris/quads polygons' % obj.yabee_name)
+                        print('WARNING:TBS: Triangulate %s to avoid non tris/quads polygons' % obj['yabee_name'])
                         bpy.context.scene.objects.active = obj
                         bpy.ops.object.modifier_apply(modifier = 'triangulate_for_TBS')
                         break
@@ -1703,7 +1703,7 @@ def write_out(fname, anims, from_actions, uv_img_as_tex, sep_anim, a_only,
 
         incl_arm = []
         for obj in bpy.context.scene.objects:
-            if obj.yabee_name in selected_obj:
+            if obj['yabee_name'] in selected_obj:
                 for mod in obj.modifiers:
                     if mod and mod.type == 'ARMATURE' \
                        and mod.object not in incl_arm \
@@ -1716,7 +1716,7 @@ def write_out(fname, anims, from_actions, uv_img_as_tex, sep_anim, a_only,
         #incl_arm = list(incl_arm)[:]
         #print(incl_arm)
         obj_list += incl_arm
-        print('Objects for export:', [obj.yabee_name for obj in obj_list])
+        print('Objects for export:', [obj['yabee_name'] for obj in obj_list])
 
         errors += gr.make_hierarchy_from_list(obj_list)
         if not errors:
diff --git a/yabee_libs/texture_processor.py b/yabee_libs/texture_processor.py
index 778d83d..72b0fa7 100644
--- a/yabee_libs/texture_processor.py
+++ b/yabee_libs/texture_processor.py
@@ -277,7 +277,7 @@ class SimpleTextures():
                                 transform.append(('Scale', (0.5, 0.5, 0.5)))
 
                             #if not tex.texture.name in list(tex_list.keys()):
-                            if not tex.texture.yabee_name in list(tex_list.keys()):
+                            if not tex.texture['yabee_name'] in list(tex_list.keys()):
                                 #try:
                                     envtype = 'MODULATE'
                                     if tex.use_map_normal:
@@ -296,7 +296,7 @@ class SimpleTextures():
 
                                     #tex_list[tex.texture.name] = {'path': t_path,
                                     #                              'scalars': scalars, 'transform': transform }
-                                    tex_list[tex.texture.yabee_name] = {'path': t_path,
+                                    tex_list[tex.texture['yabee_name']] = {'path': t_path,
                                                                         'scalars': scalars, 'transform': transform }
 
                                     if(tex.texture.use_mipmap):
@@ -371,7 +371,7 @@ class SimpleTextures():
                         for num, uv in enumerate(obj.data.uv_textures):
                             for f in uv.data:
                                 if f.image and f.image.source == 'FILE':
-                                    tex_name = '%s_%s' % (uv.name, f.image.yabee_name)
+                                    tex_name = '%s_%s' % (uv.name, f.image['yabee_name'])
                                     if not tex_name in tex_list:
                                         name = uv.name
                                         if num == 0: name = ''
@@ -554,7 +554,7 @@ class TextureBaker():
         for obj in self.obj_list:
             if obj.type == 'MESH' and self.get_active_uv(obj):
                 self._save_obj_props(obj)
-                img = bpy.data.images.new(obj.yabee_name + '_' + btype, tsizex, tsizey)
+                img = bpy.data.images.new(obj['yabee_name'] + '_' + btype, tsizex, tsizey)
                 self.rendered_images[obj.name] = img.name
                 active_uv = self.get_active_uv(obj)
                 active_uv_idx = obj.data.uv_textures[:].index(active_uv)
@@ -562,7 +562,7 @@ class TextureBaker():
                     for uvd in active_uv.data:
                         #uvd.use_image = True
                         uvd.image = img
-                    assigned_data[obj.yabee_name + '_' + btype] = (active_uv, img, active_uv_idx, BAKE_TYPES[btype][1])
+                    assigned_data[obj['yabee_name'] + '_' + btype] = (active_uv, img, active_uv_idx, BAKE_TYPES[btype][1])
                 else:
                     print('ERROR: %s have not active UV layer' % obj.name)
                     return None
